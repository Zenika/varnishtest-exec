#!/bin/sh

# This two-lines script generates the documentation web site.
#
# Why not a simple `mvn site` ?
# - maven sites are flawed
# - multi-modules sites are worse
# - staging a site needs a distribution management entry
#
# How are maven sites flawed ?
# Too many issues, let's just say that they lack clean abstraction.
#
# What's the problem with multi-modules ?
# This project has two modules because Maven makes a distinction between JARs
# and Maven plugins. If it wasn't for the plugin, their would be only one
# artifact, and things would be simpler (no hierarchy or inheritance to handle).
#
# What's the problem with distribution management ?
# The documentation is built as a *static* web site. What's the matter with the
# Maven way ? With this very script you get a full site in the `target/site'
# directory, so staging isn't even needed anymore.
#
# Then why use `mvn ... site` at all ?
# This is the simplest portable way to integrate the documentation in a Maven
# build process. The maven-site-plugin and his friends can generate a lot of
# stuff from the source tree and the build, and this is hard to obtain by other
# means.
#
# So how does it work ?  The first Maven invocation runs a default life cycle,
# and installs the artifacts in the local repository. Because for some reasons
# the maven-site-plugin can't find artifacts in the reactor. Another trick is
# to make reporting plugins use reports generated by modules when possible (eg.
# invoker and failsafe) in order to keep a flat mono-module site with full
# documentation. Some reporting goals are bound to the post-integration-test
# phase, that is when everything about the build should be "reportable". We can
# then create the site but the but the target directory MUST NOT be removed.

set -e

mvn clean install $@
mvn site $@
